---
title: Attacking uBPF VM - Part 2 Writing the fuzzer - (EN)
date: 2023-03-22 00:00:00 +0000
categories: [Fuzzing]
tags: [english, fuzzing, ubpf]
mermaid: true
---
# Attacking uBPF VM - Part 2 Writing the fuzzer - (EN)

We will now undertake a dynamic analysis of the VM to identify potential bugs. To do this, we will develop a custom fuzzer in Rust that will generate a large number of eBPF programs and execute them in the virtual machine provided by uBPF.

Given the simplicity of the target (less than 2,000 lines of code), the fuzzer will be simplistic, without seeking to optimize the number of executions per second or code coverage.

Articles:
- [Attacking uBPF VM - Part 1 Reconnaissance - (EN)](https://joachimff.github.io/posts/Attacking-uBPF-VM-Part-1-Reconnaissance-(EN)/)
- [Attacking uBPF VM - Part 2 Writing the fuzzer - (EN)](https://joachimff.github.io/posts/Attacking-uBPF-VM-Part-2-Writing-the-fuzzer-(EN)/)
- [Attacking uBPF VM - Part 3 Bug Analysis - (EN)](https://joachimff.github.io/posts/Attacking-uBPF-VM-Part-3-Bug-Analysis-(EN)/)

___This article has been translated with the help of AI.___

# Target
## Harness

The ubpf_exec function will be used as an entry point for the fuzzer, because it allows to execute eBPF programs. To work correctly, it is necessary to call the functions in the following order:

```mermaid
graph LR;
  ubpf_create-->ubpf_load-->ubpf_exec-->ubpf_destroy;
```

The instructions generated by the fuzzer will be passed as arguments to the **ubpf_load** function and executed through **ubpf_exec**. Between each execution, the VM will be destroyed and recreated to avoid side effects. We will enable the bounds_check_enabled flag (default configuration) to activate security controls.

The library will be compiled as an external library in .so format, and our Rust fuzzer will directly call the necessary functions.

## Target instrumentation

To enhance our analysis, we will compile the library by activating AddressSanitizer (ASAN), a tool for detecting memory errors in C/C++ programs that can identify a multitude of vulnerabilities at runtime, including buffer overflows, memory leaks, undefined behaviors, etc.

ASAN is practical because it crashes the program as soon as an error is detected, which is not necessarily the case in a normal execution where some uncontrolled memory accesses do not necessarily cause a segmentation fault and can therefore go unnoticed.

Modifications made to the Makefile:
```
LDLIBS := -lm -lubsan
CFLAGS += -fsanitize=address,undefined
LDFLAGS += -fsanitize=address,undefined
```

To start the fuzzer:
```
LD_PRELOAD=/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so ./target/debug/j-fuzzer
```

In theory, the virtual machine is supposed to detect infinite loops in the code. However, during tests with the fuzzer, I noticed that it was getting stuck several times in infinite loops.

To avoid this, the main execution loop was modified to force the execution to stop after 100,000 instructions. This way, the fuzzer can continue to generate and test programs without being indefinitely stuck in a loop.

```c
---while (1) {

+++for(int i = 0; i < 100000; i++){
```

# Fuzzer  

## Call an external library from Rust  

To use uBPF from our Rust fuzzer, the library is compiled as a shared library (.so) and loaded at runtime using the LoadLibrary crate. The types of each function used must be redefined in Rust, which can be tedious.

Definition of prototypes of functions called in Rust:
```rust
type UbpfVm = c_void;
type UbpfCreateFn = unsafe extern fn() -> *mut UbpfVm;
type UbpfLoadFn = unsafe extern fn(*mut UbpfVm, *const c_char, u32, *mut *const c_char) -> i32;
type UbpfCompileFn = unsafe extern fn(*mut UbpfVm, *mut *const c_char) -> u64;
type UbpfDeleteFn = unsafe extern fn(*mut UbpfVm) -> ();
type UbpfExecFn = unsafe extern fn(*mut UbpfVm, *mut i8, u32, *mut u64) -> i32;
```

Functions call:
```rust
//import lib
let lib: &'static Library = Box::leak(Box::new(Library::new("../ubpf/vm/libubpf.so").unwrap()));

//import symbol
let ubpf_create_fn: Symbol<'static, UbpfCreateFn> = lib.get(b"ubpf_create").unwrap();

//call symbol
let vm: *mut UbpfVm = ubpf_create_fn();
```

## Generate valid inputs

The fuzzer must produce random valid eBPF programs to execute in the virtual machine. To do this, we rely on the unofficial documentation of the uBPF project's eBPF instruction format.

eBPF instructions are encoded in 64 bits:
* 8 bit opcode
* 4 bit registre de destination (dst)
* 4 bit registre source (src)
* 16 bit offset
* 32 bit immediate (imm)

```
msb                                                        lsb
+------------------------+----------------+----+----+--------+
|immediate               |offset          |src |dst |opcode  |
+------------------------+----------------+----+----+--------+
```
*(Source: https://github.com/iovisor/bpf-docs/blob/master/eBPF.md)

In order to use these instructions in Rust, we have defined the following two types:
```rust
struct EbpfInstr{
  opcode: u8,
  dst: u8,
  src: u8,
  offset: u16,
  imm: i32
}

struct EbpfBytecode([c_char; 8]);
```

To generate an instruction, we proceed as follows:
-   Random selection of an opcode from the list of existing opcodes.
-   Random selection of destination and source registers.
-   Random selection of immediate value and offset, except in two particular cases:
    -   For "byteswap" instructions, we limit the possible immediate values to 16, 32, or 64.
    -   For "branch" instructions, we check that the offset value added to the PC is within the program's memory address range, i.e., between 0 and the number of program instructions.

Simplified code to generate an instruction:
```rust
fn generate_random_instr (i: i32) -> EbpfInstr{   
	let opcode = OPCODE[rand::thread_rng().gen_range(0..OPCODE.len())];
	let mut offset = 0;
	let mut imm = 0;
	
	if is_branch{
	  offset = rand::thread_rng().gen_range(-i .. (((NBR_INSTR + 1) as i32) - i - 1)) as u16;
	}
	else{
	  offset = rand::thread_rng().gen_range(0..0xFF_FF);
	}
	
	if is_bit_swap{
	  let values = [16, 32, 64];
	  imm = values[rand::thread_rng().gen_range(0..3)];
	}
	else{
	  imm = rand::thread_rng().gen::<i32>();
	}
	
	EbpfInstr{
	  opcode: opcode,
	  dst: rand::thread_rng().gen_range(0..10),
	  src: rand::thread_rng().gen_range(0..10),
	  offset: offset,
	  imm: imm
	}
}
```

## VM execution

Once the functions are loaded into the program, the main loop of the fuzzer is called:

-   A new eBPF virtual machine is created.
-   A program with a specified number of instructions (32 during testing) is generated.
-   The program is loaded into the virtual machine.
-   A buffer for the stack is allocated.
-   The program is executed in the virtual machine.
-   The virtual machine is destroyed.

Here is what the code of the main loop looks like:
```rust
loop{
	//création VM eBPF
	vm: *mut UbpfVm = ubpf_create_fn();
	
	//génération programme eBPF aléatoire
	let mut bytecode: [EbpfBytecode; NBR_INSTR + 1] = [EbpfBytecode::default(); NBR_INSTR + 1];
	
	for j in 0..NBR_INSTR as i32{
	  let instr = EbpfInstr::generate_random_instr(j);
	  let instr_byte = EbpfBytecode::from(instr);
	  
	  bytecode[j as usize] = instr_byte;
	}
	//ajoute instruction exit en fin de programe
	bytecode[NBR_INSTR] = EbpfBytecode::from(EbpfInstr::new(0x95, 0x00, 0x00, 0x0000, 0x00000000));
	
	//charge le programme dans la vm
	ubpf_load_fn(vm, bytecode.as_ptr() as *const c_char, 8 * (NBR_INSTR + 1) as u32, &mut errmsg_ptr)
	
	//allocation pointeur pour récupérer la valeur de retour
	let ret_val_ptr: *mut u64 = std::mem::MaybeUninit::<u64>::uninit().as_mut_ptr();
	
	//allocation stack
	let mut buffer: Vec<u8> = vec![0; STACK_SIZE];
	let buf_ptr = buffer.as_mut_ptr() as *mut c_char;
	
	//execute le programme
	ubpf_exec_fn(vm, buf_ptr, STACK_SIZE, ret_val_ptr);
	
	//destruction vm
	ubpf_destroy_fn(vm);
	[...]
}
```

The fuzzer is now functional, you can find the complete code on my [github.com/joachimff/eBPF-fuzzer](https://github.com/joachimff/eBPF-fuzzer). 

The tests are performed in an Ubuntu VM in WSL on a laptop, the performance of the fuzzer is low (4000 exec/s), however this will be enough to find interesting bugs since after only 5 minutes of execution, 2 bugs have been identified.

[Attacking uBPF VM - Part 3 Bug Analysis - (EN)](https://joachimff.github.io/posts/Attacking-uBPF-VM-Part-3-Bug-Analysis-(EN)/)